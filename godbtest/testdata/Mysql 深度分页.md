# Mysql 深度分页

[知乎兰殇blog](https://zhuanlan.zhihu.com/p/689273185)

分页是一个很普通的功能，只要是个后端开发就要写分页，那为什么要分页？

从业务上来讲，即使系统返回所有数据，用户绝大多数情况下是不会看后面的数据的。
技术上，因为要考虑取数据的成本，目标服务器磁盘、内存、网络带宽，以及请求发起方自身是否能承受大批量数据。

MySQL 分页语法:

```sql
select * from table limit 0, 20
```

思考: 使用分页，上面提到的第 2 点，这些成本真的能降低吗？

启动 MySQL:

`docker run --name mysql -e MYSQL_DATABASE=db1 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:8.4.0-oracle`

建表，造数据:

```sql
CREATE TABLE `account` (
 `id` int NOT NULL AUTO_INCREMENT COMMENT 'Id',
 `name` varchar(255) DEFAULT NULL,
 `balance` int DEFAULT NULL,
 `create_time` datetime NOT NULL,
 `update_time` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP,
 PRIMARY KEY (`id`),
 KEY `idx_name` (`name`),
 KEY `idx_update_time` (`update_time`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4;

-- 先初始化数据
DELIMITER //
CREATE PROCEDURE InsertRandomAccounts(IN num_rows INT)
BEGIN
  DECLARE i INT DEFAULT 0;
  WHILE i < num_rows DO
    SET @name = CONCAT('Account', LPAD(i, 6, '0'));
    SET @balance = FLOOR(RAND() * 10000); -- 随机生成一个0到9999之间的余额
    SET @create_time = NOW() - INTERVAL FLOOR(RAND() * 3650) DAY; -- 随机生成一个过去3650天内的创建时间
    SET @update_time = NOW(); -- 更新时间设置为当前时间

    INSERT INTO account (name, balance, create_time, update_time)
    VALUES (@name, @balance, @create_time, @update_time);

    SET i = i + 1;
  END WHILE;
END //
DELIMITER ;

-- 调用存储过程插入两百万条数据  （插入数据前可先将索引删除来提升效率）
CALL InsertRandomAccounts(2000000);

-- 删除存储过程（如果你不再需要它）
DROP PROCEDURE IF EXISTS InsertRandomAccounts;
```

也可以用 godbtest 直接造数据:

```sh
$ godbtest
> %set --cost -n 2000000;
>
> insert into account(name, balance, create_time, update_time) values('LPAD@seq(1,%06d)', '@random_int(0-9999)',now(), '@random_time(yyyy-MM-dd HH:mm:ss,2021-01-01 00:00:00,2024-06-06 00:00:00)')\P
2024/07/16 10:21:52 threads(goroutines): 12, txBatch: 1, batch: 100 with 2000000 request(s)
2024/07/16 10:21:52 preparedQuery: insert into account(name, balance, create_time, update_time)  values (?, ?, now(), ?)
2000000 / 2000000 [------------------------------------------------------------------------] 100.00% 11759 p/s 2m50s
2024/07/16 10:24:43 Average 85.138µs/record, total cost: 2m50.276326426s, total affected: 2000000, errors: 0
>
```

## 1 没有查询条件，没有排序

1. `select * from account a limit 1000000,10;` 100w 之后的数据，耗时： 3.1s
2. 加主键排序 `select * from account a order by id limit 1000000,10;` 耗时：有所降低 3.0s


执行计划对比

```sh
> select * from account a limit 1000000,10;
+---------+------------+---------+---------------------+---------------------+
|      id | name       | balance | create_time         | update_time         |
+---------+------------+---------+---------------------+---------------------+
| 1000001 | LPAD000001 |    1872 | 2024-07-16 02:23:19 | 2021-04-02 05:38:26 |
| 1000002 | LPAD000002 |    8034 | 2024-07-16 02:23:19 | 2022-06-20 19:13:30 |
| 1000003 | LPAD000003 |    5301 | 2024-07-16 02:23:19 | 2021-04-09 01:24:16 |
| 1000004 | LPAD000004 |    4614 | 2024-07-16 02:23:19 | 2021-11-19 18:58:25 |
| 1000005 | LPAD000005 |     182 | 2024-07-16 02:23:19 | 2021-11-09 00:44:33 |
| 1000006 | LPAD000006 |     618 | 2024-07-16 02:23:19 | 2024-04-21 08:54:53 |
| 1000007 | LPAD000007 |    9698 | 2024-07-16 02:23:19 | 2021-03-27 10:02:12 |
| 1000008 | LPAD000008 |    7977 | 2024-07-16 02:23:19 | 2021-03-16 01:06:51 |
| 1000009 | LPAD000009 |    9800 | 2024-07-16 02:23:19 | 2023-10-31 14:54:49 |
| 1000010 | LPAD000010 |    5061 | 2024-07-16 02:23:19 | 2023-06-14 13:25:04 |
+---------+------------+---------+---------------------+---------------------+
2024/07/16 10:28:40 Cost 3.173560197s
> explain select * from account a limit 1000000,10;
+----+-------------+-------+------------+------+---------------+-------+---------+-------+---------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   |    rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+---------+----------+-------+
|  1 | SIMPLE      | a     | <nil>      | ALL  | <nil>         | <nil> | <nil>   | <nil> | 2020213 | 100      | <nil> |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+---------+----------+-------+
2024/07/16 10:28:46 Cost 1.67374ms
>
> select * from account a order by id limit 1000000,10;
+---------+------------+---------+---------------------+---------------------+
|      id | name       | balance | create_time         | update_time         |
+---------+------------+---------+---------------------+---------------------+
| 1000001 | LPAD000001 |    1872 | 2024-07-16 02:23:19 | 2021-04-02 05:38:26 |
| 1000002 | LPAD000002 |    8034 | 2024-07-16 02:23:19 | 2022-06-20 19:13:30 |
| 1000003 | LPAD000003 |    5301 | 2024-07-16 02:23:19 | 2021-04-09 01:24:16 |
| 1000004 | LPAD000004 |    4614 | 2024-07-16 02:23:19 | 2021-11-19 18:58:25 |
| 1000005 | LPAD000005 |     182 | 2024-07-16 02:23:19 | 2021-11-09 00:44:33 |
| 1000006 | LPAD000006 |     618 | 2024-07-16 02:23:19 | 2024-04-21 08:54:53 |
| 1000007 | LPAD000007 |    9698 | 2024-07-16 02:23:19 | 2021-03-27 10:02:12 |
| 1000008 | LPAD000008 |    7977 | 2024-07-16 02:23:19 | 2021-03-16 01:06:51 |
| 1000009 | LPAD000009 |    9800 | 2024-07-16 02:23:19 | 2023-10-31 14:54:49 |
| 1000010 | LPAD000010 |    5061 | 2024-07-16 02:23:19 | 2023-06-14 13:25:04 |
+---------+------------+---------+---------------------+---------------------+
2024/07/16 10:28:54 Cost 3.018169329s
> explain select * from account a order by id limit 1000000,10;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+---------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   |    rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+---------+----------+-------+
|  1 | SIMPLE      | a     | <nil>      | index | <nil>         | PRIMARY | 4       | <nil> | 1000010 | 100      | <nil> |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+---------+----------+-------+
2024/07/16 10:29:03 Cost 2.571307ms
```

可以看到带主键排序使用了主键索引，且只读取了需要的前 n 条数据，所以快。

因此, **结论 1：即使业务上看起来没有任何条件还不需要排序，也加上 order by 主键。**

这里其实有另一个问题：如果不带排序条件，MySQL 默认是什么排序？

通常认为是主键，但通过查资料发现并不一定，这里有个物理顺序和逻辑顺序的区别，如：删除原有数据后再插入复用旧 id 的数据，
可能会由于存放在不同页上造成物理顺序与逻辑顺序不一致，此时可以通过优化表改善：optimize table table_name。

## 2 带排序 - 排序字段没有索引

```sql
-- 删除索引 idx_update_time
alter table account drop index idx_update_time;
-- 添加索引 idx_update_time
create index idx_update_time on account (update_time);
```


1. 先将 idx_update_time 索引删除 `select * from account order by update_time desc limit 1000,10;` 执行时间: 7.5s
2. 添加 idx_update_time 索引, `select * from account order by update_time desc limit 1000,10;` 执行时间: 195ms

```sh
> alter table account drop index idx_update_time;
2024/07/16 10:30:21 Result: lastInsertId: 0, rowsAffected: 0, cost: 83.556343ms
>
> select * from account order by update_time desc limit 1000,10;
+---------+------------+---------+---------------------+---------------------+
|      id | name       | balance | create_time         | update_time         |
+---------+------------+---------+---------------------+---------------------+
|  137618 | LPAD000018 |    8758 | 2024-07-16 02:22:02 | 2024-06-05 08:48:51 |
| 1924190 | LPAD000090 |    9990 | 2024-07-16 02:24:37 | 2024-06-05 08:45:29 |
| 1191867 | LPAD000067 |    1805 | 2024-07-16 02:23:43 | 2024-06-05 08:44:46 |
|  966501 | LPAD000001 |     895 | 2024-07-16 02:23:15 | 2024-06-05 08:44:40 |
| 1886803 | LPAD000003 |    9881 | 2024-07-16 02:24:35 | 2024-06-05 08:44:27 |
|  358043 | LPAD000043 |    5402 | 2024-07-16 02:22:15 | 2024-06-05 08:43:52 |
| 1219064 | LPAD000064 |    2958 | 2024-07-16 02:23:46 | 2024-06-05 08:43:47 |
|  937577 | LPAD000077 |    5732 | 2024-07-16 02:23:12 | 2024-06-05 08:40:05 |
|  439909 | LPAD000009 |    9507 | 2024-07-16 02:22:19 | 2024-06-05 08:39:21 |
|  420624 | LPAD000024 |    6321 | 2024-07-16 02:22:18 | 2024-06-05 08:38:57 |
+---------+------------+---------+---------------------+---------------------+
2024/07/16 10:30:44 Cost 7.551502782s
> explain select * from account order by update_time desc limit 1000,10;
+----+-------------+---------+------------+------+---------------+-------+---------+-------+---------+----------+----------------+
| id | select_type | table   | partitions | type | possible_keys | key   | key_len | ref   |    rows | filtered | Extra          |
+----+-------------+---------+------------+------+---------------+-------+---------+-------+---------+----------+----------------+
|  1 | SIMPLE      | account | <nil>      | ALL  | <nil>         | <nil> | <nil>   | <nil> | 1856512 | 100      | Using filesort |
+----+-------------+---------+------------+------+---------------+-------+---------+-------+---------+----------+----------------+
2024/07/16 10:30:48 Cost 1.559072ms
>
> create index idx_update_time on account (update_time);
2024/07/16 10:31:10 Result: lastInsertId: 0, rowsAffected: 0, cost: 8.779748606s
> select * from account order by update_time desc limit 1000,10;
+---------+------------+---------+---------------------+---------------------+
|      id | name       | balance | create_time         | update_time         |
+---------+------------+---------+---------------------+---------------------+
|  137618 | LPAD000018 |    8758 | 2024-07-16 02:22:02 | 2024-06-05 08:48:51 |
| 1924190 | LPAD000090 |    9990 | 2024-07-16 02:24:37 | 2024-06-05 08:45:29 |
| 1191867 | LPAD000067 |    1805 | 2024-07-16 02:23:43 | 2024-06-05 08:44:46 |
|  966501 | LPAD000001 |     895 | 2024-07-16 02:23:15 | 2024-06-05 08:44:40 |
| 1886803 | LPAD000003 |    9881 | 2024-07-16 02:24:35 | 2024-06-05 08:44:27 |
|  358043 | LPAD000043 |    5402 | 2024-07-16 02:22:15 | 2024-06-05 08:43:52 |
| 1219064 | LPAD000064 |    2958 | 2024-07-16 02:23:46 | 2024-06-05 08:43:47 |
|  937577 | LPAD000077 |    5732 | 2024-07-16 02:23:12 | 2024-06-05 08:40:05 |
|  439909 | LPAD000009 |    9507 | 2024-07-16 02:22:19 | 2024-06-05 08:39:21 |
|  420624 | LPAD000024 |    6321 | 2024-07-16 02:22:18 | 2024-06-05 08:38:57 |
+---------+------------+---------+---------------------+---------------------+
2024/07/16 10:31:16 Cost 195.979952ms
> explain select * from account order by update_time desc limit 1000,10;
+----+-------------+---------+------------+-------+---------------+-----------------+---------+-------+------+----------+---------------------+
| id | select_type | table   | partitions | type  | possible_keys | key             | key_len | ref   | rows | filtered | Extra               |
+----+-------------+---------+------------+-------+---------------+-----------------+---------+-------+------+----------+---------------------+
|  1 | SIMPLE      | account | <nil>      | index | <nil>         | idx_update_time | 5       | <nil> | 1010 | 100      | Backward index scan |
+----+-------------+---------+------------+-------+---------------+-----------------+---------+-------+------+----------+---------------------+
2024/07/16 10:31:25 Cost 1.616529ms
```

可以看到有索引的表，直接走索引取前 n 条数据，不需要全表扫描，也不会用到 filesor。

**结论 2：给常用字段加索引，包括排序字段。**

新的问题： 以上 2 个场景看似已可以解决大部分分页问题，但：

排序字段有索引就一定快吗？1k的时候速度较快，换成查询 1w 之后的数据呢？ 如果当前表已经有多个索引，不适合再添加索引了呢？

## 3 排序字段有索引，但分页再深一点： 从 100w 开始取 20 条

```sql
select * from account order by update_time desc limit 1000000,10;
```

耗时： 非常慢 13s

```sh
> select * from account order by update_time desc limit 1000000,10;
+---------+------------+---------+---------------------+---------------------+
|      id | name       | balance | create_time         | update_time         |
+---------+------------+---------+---------------------+---------------------+
| 1160161 | LPAD000061 |    6710 | 2024-07-16 02:23:40 | 2022-09-19 15:13:24 |
|   76353 | LPAD000053 |    3893 | 2024-07-16 02:21:59 | 2022-09-19 15:08:52 |
| 1281659 | LPAD000059 |    8668 | 2024-07-16 02:23:51 | 2022-09-19 15:08:25 |
| 1403947 | LPAD000047 |     190 | 2024-07-16 02:24:01 | 2022-09-19 15:08:13 |
| 1113569 | LPAD000069 |    5241 | 2024-07-16 02:23:35 | 2022-09-19 15:07:33 |
| 1643136 | LPAD000036 |    6009 | 2024-07-16 02:24:18 | 2022-09-19 15:06:48 |
|  212420 | LPAD000020 |    4833 | 2024-07-16 02:22:06 | 2022-09-19 15:04:20 |
| 1375958 | LPAD000058 |    3784 | 2024-07-16 02:23:59 | 2022-09-19 15:02:02 |
|  561501 | LPAD000001 |     748 | 2024-07-16 02:22:30 | 2022-09-19 15:01:54 |
|  244113 | LPAD000013 |    1901 | 2024-07-16 02:22:08 | 2022-09-19 15:01:40 |
+---------+------------+---------+---------------------+---------------------+
2024/07/16 10:32:56 Cost 13.821397336s
> explain select * from account order by update_time desc limit 1000000,10;
+----+-------------+---------+------------+------+---------------+-------+---------+-------+---------+----------+----------------+
| id | select_type | table   | partitions | type | possible_keys | key   | key_len | ref   |    rows | filtered | Extra          |
+----+-------------+---------+------------+------+---------------+-------+---------+-------+---------+----------+----------------+
|  1 | SIMPLE      | account | <nil>      | ALL  | <nil>         | <nil> | <nil>   | <nil> | 1856512 | 100      | Using filesort |
+----+-------------+---------+------------+------+---------------+-------+---------+-------+---------+----------+----------------+
2024/07/16 10:33:15 Cost 5.7867ms

```

过执行计划发现，并没有走索引，为什么没有走索引？ 因为 mysql 优化器发现这条 sql 查询行数超过一定比例（据说是 30%，但测试下来并不完全是）就会自动转换为全表扫描，能不能强制走索引呢？ 

可以的，加 force index(idx)。 

## 4 强制索引


```sql
select * from account force index(idx_update_time) order by update_time desc limit 1000000,10;
```

耗时: 1m4s

```sh
> select * from account force index(idx_update_time) order by update_time desc limit 1000000,10;
+---------+------------+---------+---------------------+---------------------+
|      id | name       | balance | create_time         | update_time         |
+---------+------------+---------+---------------------+---------------------+
| 1160161 | LPAD000061 |    6710 | 2024-07-16 02:23:40 | 2022-09-19 15:13:24 |
|   76353 | LPAD000053 |    3893 | 2024-07-16 02:21:59 | 2022-09-19 15:08:52 |
| 1281659 | LPAD000059 |    8668 | 2024-07-16 02:23:51 | 2022-09-19 15:08:25 |
| 1403947 | LPAD000047 |     190 | 2024-07-16 02:24:01 | 2022-09-19 15:08:13 |
| 1113569 | LPAD000069 |    5241 | 2024-07-16 02:23:35 | 2022-09-19 15:07:33 |
| 1643136 | LPAD000036 |    6009 | 2024-07-16 02:24:18 | 2022-09-19 15:06:48 |
|  212420 | LPAD000020 |    4833 | 2024-07-16 02:22:06 | 2022-09-19 15:04:20 |
| 1375958 | LPAD000058 |    3784 | 2024-07-16 02:23:59 | 2022-09-19 15:02:02 |
|  561501 | LPAD000001 |     748 | 2024-07-16 02:22:30 | 2022-09-19 15:01:54 |
|  244113 | LPAD000013 |    1901 | 2024-07-16 02:22:08 | 2022-09-19 15:01:40 |
+---------+------------+---------+---------------------+---------------------+
2024/07/16 10:35:24 Cost 1m4.519219783s
> explain select * from account force index(idx_update_time) order by update_time desc limit 1000000,10;
+----+-------------+---------+------------+-------+---------------+-----------------+---------+-------+---------+----------+---------------------+
| id | select_type | table   | partitions | type  | possible_keys | key             | key_len | ref   |    rows | filtered | Extra               |
+----+-------------+---------+------------+-------+---------------+-----------------+---------+-------+---------+----------+---------------------+
|  1 | SIMPLE      | account | <nil>      | index | <nil>         | idx_update_time | 5       | <nil> | 1000010 | 100      | Backward index scan |
+----+-------------+---------+------------+-------+---------------+-----------------+---------+-------+---------+----------+---------------------+
2024/07/16 10:35:46 Cost 1.779933ms
```

反而更慢了，看来MySQL内部做的优化还是很充分的，数据量大的时候直接不走索引了

**结论 3：即使有索引，再深一点的分页也会有问题，要避免。**

以上尝试结果都没有很好的解决深分页性能问题，那是否有更好的解决方案？ 有！

## 5 带 last_条件查询

```sql
select * from account
where id > #{last_id}
and update_time > #{last_update_time}
order by update desc
limit 0, 20;
```

性能与正常浅分页没差别，但前提是 `last_*` 字段有索引。

同时，该方案受使用场景限制，如跳页、多排序字段等，last_* 都将无法使用。

推荐使用场景：没有页码的应用，如：滑动加载下一页、只有上下页按钮等。


## 6 联表子查询

将场景 4 中强制索的 sql 改为子查询，先测试排序字段有索引的 t2 表。

```sql
select * from account a join (select id from account order by update_time desc limit 1000000,10) b on a.id = b.id;
```

执行时间: 886.323811ms 效果明显

删除idx_update_time索引 再执行, 5.607187581s,(比 7.551502782s 快点)

改成子查询关联后，无论有没有索引都节省了大量时间，下面来分析下原因。

这两条关联查询的执行计划对比差距还是在于子查询是否使用索引排序，1 使用索引所以快。

区别： 全表扫描与强制索引区别上面已经讲过，那强制索引跟子查询区别是什么？

看起来就只是多了一个 Using index，那什么是 Using index 呢?

简单说就是直接通过索引树就能拿到查询字段的值，所以快的原因是子查询方式减少了回表查询操作，进而减少了大量数据的回表 IO，因此更高效。


```sh
> select a.* from account a join (select id from account order by update_time desc limit 1000000,10) b on a.id = b.id;
+---------+------------+---------+---------------------+---------------------+
|      id | name       | balance | create_time         | update_time         |
+---------+------------+---------+---------------------+---------------------+
| 1160161 | LPAD000061 |    6710 | 2024-07-16 02:23:40 | 2022-09-19 15:13:24 |
|   76353 | LPAD000053 |    3893 | 2024-07-16 02:21:59 | 2022-09-19 15:08:52 |
| 1281659 | LPAD000059 |    8668 | 2024-07-16 02:23:51 | 2022-09-19 15:08:25 |
| 1403947 | LPAD000047 |     190 | 2024-07-16 02:24:01 | 2022-09-19 15:08:13 |
| 1113569 | LPAD000069 |    5241 | 2024-07-16 02:23:35 | 2022-09-19 15:07:33 |
| 1643136 | LPAD000036 |    6009 | 2024-07-16 02:24:18 | 2022-09-19 15:06:48 |
|  212420 | LPAD000020 |    4833 | 2024-07-16 02:22:06 | 2022-09-19 15:04:20 |
| 1375958 | LPAD000058 |    3784 | 2024-07-16 02:23:59 | 2022-09-19 15:02:02 |
|  561501 | LPAD000001 |     748 | 2024-07-16 02:22:30 | 2022-09-19 15:01:54 |
|  244113 | LPAD000013 |    1901 | 2024-07-16 02:22:08 | 2022-09-19 15:01:40 |
+---------+------------+---------+---------------------+---------------------+
2024/07/16 10:37:30 Cost 886.323811ms
> explain select a.* from account a join (select id from account order by update_time desc limit 1000000,10) b on a.id = b.id;
+----+-------------+------------+------------+--------+---------------+-----------------+---------+-------+---------+----------+----------------------------------+
| id | select_type | table      | partitions | type   | possible_keys | key             | key_len | ref   |    rows | filtered | Extra                            |
+----+-------------+------------+------------+--------+---------------+-----------------+---------+-------+---------+----------+----------------------------------+
|  1 | PRIMARY     | <derived2> | <nil>      | ALL    | <nil>         | <nil>           | <nil>   | <nil> | 1000010 | 100      | <nil>                            |
|  1 | PRIMARY     | a          | <nil>      | eq_ref | PRIMARY       | PRIMARY         | 4       | b.id  |       1 | 100      | <nil>                            |
|  2 | DERIVED     | account    | <nil>      | index  | <nil>         | idx_update_time | 5       | <nil> | 1000010 | 100      | Backward index scan; Using index |
+----+-------------+------------+------------+--------+---------------+-----------------+---------+-------+---------+----------+----------------------------------+
2024/07/16 10:37:44 Cost 4.358924ms

> alter table account drop index idx_update_time;
2024/07/16 10:08:40 Result: lastInsertId: 0, rowsAffected: 0, cost: 99.6861ms
>
> alter table account drop index idx_update_time;
2024/07/16 10:38:18 Result: lastInsertId: 0, rowsAffected: 0, cost: 87.898403ms
>
> select a.* from account a join (select id from account order by update_time desc limit 1000000,10) b on a.id = b.id;
+---------+------------+---------+---------------------+---------------------+
|      id | name       | balance | create_time         | update_time         |
+---------+------------+---------+---------------------+---------------------+
| 1160161 | LPAD000061 |    6710 | 2024-07-16 02:23:40 | 2022-09-19 15:13:24 |
|   76353 | LPAD000053 |    3893 | 2024-07-16 02:21:59 | 2022-09-19 15:08:52 |
| 1281659 | LPAD000059 |    8668 | 2024-07-16 02:23:51 | 2022-09-19 15:08:25 |
| 1403947 | LPAD000047 |     190 | 2024-07-16 02:24:01 | 2022-09-19 15:08:13 |
| 1113569 | LPAD000069 |    5241 | 2024-07-16 02:23:35 | 2022-09-19 15:07:33 |
| 1643136 | LPAD000036 |    6009 | 2024-07-16 02:24:18 | 2022-09-19 15:06:48 |
|  212420 | LPAD000020 |    4833 | 2024-07-16 02:22:06 | 2022-09-19 15:04:20 |
| 1375958 | LPAD000058 |    3784 | 2024-07-16 02:23:59 | 2022-09-19 15:02:02 |
|  561501 | LPAD000001 |     748 | 2024-07-16 02:22:30 | 2022-09-19 15:01:54 |
|  244113 | LPAD000013 |    1901 | 2024-07-16 02:22:08 | 2022-09-19 15:01:40 |
+---------+------------+---------+---------------------+---------------------+
2024/07/16 10:38:30 Cost 5.607187581s
> explain select a.* from account a join (select id from account order by update_time desc limit 1000000,10) b on a.id = b.id;
+----+-------------+------------+------------+--------+---------------+---------+---------+-------+---------+----------+----------------+
| id | select_type | table      | partitions | type   | possible_keys | key     | key_len | ref   |    rows | filtered | Extra          |
+----+-------------+------------+------------+--------+---------------+---------+---------+-------+---------+----------+----------------+
|  1 | PRIMARY     | <derived2> | <nil>      | ALL    | <nil>         | <nil>   | <nil>   | <nil> | 1000010 | 100      | <nil>          |
|  1 | PRIMARY     | a          | <nil>      | eq_ref | PRIMARY       | PRIMARY | 4       | b.id  |       1 | 100      | <nil>          |
|  2 | DERIVED     | account    | <nil>      | ALL    | <nil>         | <nil>   | <nil>   | <nil> | 1856512 | 100      | Using filesort |
+----+-------------+------------+------------+--------+---------------+---------+---------+-------+---------+----------+----------------+
2024/07/16 10:38:33 Cost 2.120553ms
```
